# 实体模型定义

实体模型定义了应用程序中的数据结构和关系。它们是数据库表的抽象表示，框架使用`EntityFramework Core`来处理数据访问和操作，本篇文章将指引开发者如何更规范的定义实体模型。

## 风格一致性

EF Core 支持两种方式去定义实体模型中与数据库相关的配置：

- 数据注解（Data Annotations），即使用特性标签。
- Fluent API，在`OnModelCreating`方法中使用代码配置。

其中，在Fluent API的基础上，可使用`IEntityTypeConfiguration`接口将实体配置拆分到单独的类中。

请根据团队习惯选择合适的方式，重要的是保持一致性，这里提供两种常见的实践：

- 全部使用`IEntityTypeConfiguration`对每个实体进行配置。
- 使用数据注解进行简单配置(如长度，主键等)，复杂配置使用`Fluent API`(如关系，转换器，Json等)。

## 约定与规范

在开发约定与规范中，有给出定义实体模型的规范和约定，这是建议但不强制的，如果没有充分的理由，建议遵循这些约定。

- 所有实体类默认继承自`EntityBase`，该类定义了`Id`、`CreatedAt`、`UpdatedAt`,`IsDeleted`常用属性。
- `Id`属性默认使用`Guid`类型，客户端Guid V7生成。
- string类型，要定义最大长度，除非明确不限长度。
- decimal类型，精度和小数位数需要明确。
  - 对于较小范围的decimal类型，建议使用decimal(10, 2)
  - 对于较大范围的decimal类型，建议使用decimal(18, 6)
  
    ```csharp
    [Column(TypeName = "decimal(10,2)")]
    public decimal TotalPrice { get; set; }
    ```

- 所有枚举值必须添加`[Description]`特性。
- 时间类型使用`DateTimeOffset`，而不是`DateTime`，以确保时间信息是完整的。
- 明确仅为日期的属性，使用`DateOnly`类型。
- 明确仅为时间的属性，使用`TimeOnly`类型。

## 关系映射

EF Core通过导航属性能够自动识别一对多和多对多关系，我们也可以使用`Fluent API`来明确配置关系，尤其是在一对一和多对多的中间表关系，这里遵循官方的定义方式即可。

除此之外，根据实践经验，建议遵循以下约定：

### 显示定义关联Id属性

如博客与用户关联：

```csharp
public class Blog : EntityBase
{
    public string Title { get; set; }
    // 显示定义关联Id属性
    public Guid UserId { get; set; }
    [ForeignKey("UserId")]
    public User User { get; set; }
}
```

虽然`UserId`属性不是必须的，但强烈建议显示定义，这会让后续的查询更加灵活和方便。

### 模块间关联关系

在实际应用中，通常我们会拆分多个模块，在一定程度上实现关注点分离，以便保持结构清晰，更好的开发和维护。

但很多时候，实体模型之间是跨模块关联的，那么应该如何定义关联关系呢？

通常我们会将业务相近的实体在一个模块中定义，**在同一模块中的实体，建议定义导航属性，也就是数据库中包含外键约束。**

对于像**用户模块**，其他模块中的实体很多都需要关联用户，那么在其他实体定义时，可以只定义`UserId`属性，而不定义导航属性`User`。

> [!TIP]
> 在可能的情况下，最好使用外键约束，这样可以确保数据的完整性和一致性。在必要的时候，你可以去除外键约束。
>
> 如果你一开始没有外键约束，再添加外键约束可能会非常麻烦。
