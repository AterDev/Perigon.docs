# Relational Database

This article introduces best practices for relational database design and use.

## Choosing a Database

In the .NET ecosystem, the first choice is `SQL Server`, followed by `PostgreSQL`.

Choose `SQL Server` if paid, choose `PostgreSQL` if free.

### Brief Reasons

- Powerful functionality, wide applicability.
- Very good support in the .NET ecosystem, with Microsoft development team support behind them.
- EF Core support is very good and updated in a timely manner.

> [!NOTE]
> New projects should directly use `SQL Server 2025+` and `PostgreSQL 18+`.

## Operating Databases

### Using Entity Framework Core

EF Core is Microsoft's official ORM framework. It is recommended to use EF Core as the regular data access method. It also supports native SQL queries and has been optimized by the official and community, with very high query efficiency.

### Batch Operations

This refers to large-scale data insertion, update, delete and other operations focused on speed.

EF Core is not suitable for this type of operation. You can use: [EFCore.BulkExtensions](https://github.com/borisdj/EFCore.BulkExtensions), which uses different underlying implementations for different databases to achieve efficient batch operations.

## Database Table Structure Design

We recommend some common practices and guidance to help you save time arguing about design.

### Foreign Keys

❌ Uniformly not using foreign keys is a "brain-dead" approach that loses an important feature of relational databases.

We recommend that you use foreign keys in the same domain model to enhance constraints. In cross-domain models, selectively use foreign keys.

A typical scenario is the `user entity`, which is usually cross-domain, or even cross-service, cross-database. In this case, foreign key associations should not or cannot be used.

### Field Type Selection

Similarly, to reduce time spent arguing, we recommend some common field type choices.

- ✅Use `Guid` for primary keys, generated by the client, using `Guid V7`.
- ✅Avoid using string separators to represent multiple values, and do not use association tables, directly use array types (PostgreSQL) or JSON types (SQL Server).
- ✅Use `DateTimeOffset` for time types, and uniformly convert to UTC time when storing.
- ✅Use `DateOnly` for date types, and uniformly convert to UTC date when storing.
- ✅Only when necessary, use optimistic lock fields, such as `RowVersion`.

> [!TIP]
> Avoid wasting time in meaningless arguments, directly use these recommended practices, unless they do not meet your business needs.

## Database Migration

In the development iteration process, the database structure will also be updated. It is recommended to use the `Code First` approach to centrally manage the database structure and avoid differences caused by manual operations.

The `MigrationsService` project is used to update the database structure. When we start the application through `AppHost`, it will automatically apply the latest database migrations, and other services will start after it completes.

In the `scripts` directory, a script `EFMigrations.ps1` for generating migrations is provided. You can directly use it to generate migrations, or modify it according to actual needs. The generated migration files will be in the `EntityFramework/Migrations` directory by default.

## Multi-Database Support

In the `AppDbContext` directory of the `EntityFramework` project, add additional `DbContext`.

Then inject the added `DbContext` in the `FrameworkExtensions` extension class of the `ServiceDefaults` project.

When using, obtain the corresponding `DbContext` instance through the `UniversalDbFactory` factory class.
