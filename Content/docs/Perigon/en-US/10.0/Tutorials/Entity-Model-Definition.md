# Entity Model Definition

Entity models define the data structure and relationships in an application. They are abstract representations of database tables. The framework uses `EntityFramework Core` to handle data access and operations. This article will guide developers on how to define entity models more standardly.

## Style Consistency

EF Core supports two ways to define entity model configurations related to the database:

- Data Annotations, i.e., using attribute tags.
- Fluent API, using code configuration in the `OnModelCreating` method.

Among them, on the basis of Fluent API, you can use the `IEntityTypeConfiguration` interface to split entity configuration into separate classes.

Please choose the appropriate method according to team habits. The important thing is to maintain consistency. Here are two common practices:

- Use `IEntityTypeConfiguration` to configure each entity.
- Use data annotations for simple configuration (such as length, primary key, etc.), and use `Fluent API` for complex configuration (such as relationships, converters, Json, etc.).

## Conventions and Standards

Development conventions and standards provide specifications and conventions for defining entity models. These are recommended but not mandatory. If there is no sufficient reason, it is recommended to follow these conventions.

- Entities of different modules should be in separate folders, and namespaces should correspond.
- All model properties need comments, and all enums must add [Description] attribute descriptions.
- All entity classes inherit from `EntityBase` by default, which defines commonly used properties such as `Id`, `CreatedAt`, `UpdatedAt`, `IsDeleted`.
- The `Id` property uses the `Guid` type by default, generated by the client using Guid V7.
- For string types, define a maximum length unless explicitly unlimited.
- For decimal types, precision and decimal places need to be explicit.
  - For smaller range decimal types, it is recommended to use decimal(10, 2)
  - For larger range decimal types, it is recommended to use decimal(18, 6)
  
    ```csharp
    [Column(TypeName = "decimal(10,2)")]
    public decimal TotalPrice { get; set; }
    ```

- All enum values must add the `[Description]` attribute.
- Use `DateTimeOffset` for time types, not `DateTime`, to ensure time information is complete.
- For properties that are explicitly dates only, use the `DateOnly` type.
- For properties that are explicitly times only, use the `TimeOnly` type.

## EntityBase

`EntityBase` is an abstract base class. By default, entities inherit from it. It defines some commonly used properties:

```csharp
public abstract class EntityBase
{
    [Key]
    public Guid Id { get; set; } = Guid.CreateVersion7();
    public DateTimeOffset CreatedTime { get; private set; } = DateTimeOffset.UtcNow;
    public DateTimeOffset UpdatedTime { get; set; }
    public bool IsDeleted { get; set; }
    public Guid TenantId { get; set; }
}
```

From this we can see:

- Defines the default primary key Id, which is an ordered GUID generated by the client,
- Defines the creation time and default value. As long as the entity is created, it will be automatically assigned to the current UTC time.
- Defines the update time property, which is automatically assigned to the current UTC time when updated.
- Defines the soft delete property `IsDeleted`. The framework filters out soft-deleted data by default.
- `TenantId` can be chosen to inherit or not according to actual needs.

## Unique Constraints

When designing entities, you must consider the uniqueness of entities and add unique constraints. Unique constraints can effectively prevent data duplication and conflicts.

The `UpsertAsync` method in ManagerBase will judge whether to insert or update data based on the primary key, and then prevent duplicate data insertion based on unique constraints.

Since the system implements tenant mode by default, it uniformly handles the `TenantId` index. This means you don't need to add `TenantId` to the unique constraint for each entity (it's okay to add it), the system will automatically handle it for you. At the same time, for unique constraints, `HasFilter` filtering indexes will be automatically added to filter out soft-deleted data.


> [!TIP]
> You can modify the default implementation in the `ConfigureMultiTenantUniqueIndexes` method in `ContextBase.cs`.

## Optimistic Concurrency

For entities that need to handle concurrent updates, it is recommended to use optimistic concurrency control, which is implemented by adding a property to the entity.

```csharp
[Timestamp]
public byte[] RowVersion { get; set; }
```

The above is compatible with multiple databases. If you want to leverage the database's own features, such as Postgres's `xmin`, you can define it like this:

```csharp
[Timestamp]
public unit RowVersion { get; set; }
```

## Relationship Mapping

EF Core can automatically identify one-to-many and many-to-many relationships through navigation properties. We can also use `Fluent API` to explicitly configure relationships, especially for one-to-one and many-to-many intermediate table relationships. Just follow the official definition method.

In addition, based on practical experience, it is recommended to follow the following conventions:


### Explicitly Define Associated Id Properties

For example, blog associated with user:

```csharp
public class Blog : EntityBase
{
    public string Title { get; set; }
    // Explicitly define associated Id property
    public Guid UserId { get; set; }
    [ForeignKey(nameof(UserId))]
    public User User { get; set; }
}
```

Although the `UserId` property is not required, it is strongly recommended to explicitly define it, which will make subsequent queries more flexible and convenient.


**For many-to-many relationships, it is recommended to explicitly define the intermediate table entity and explicitly define associated Id properties**.

### Using Json and Arrays to Simplify Relationships

Appropriate use of data types provided by the database such as Json and arrays (Postgres), to avoid creating too many association tables, will effectively avoid complexity.

EF Core has provided very good support for Json column queries.

### Inter-module Association Relationships

In actual applications, we usually split multiple modules to implement separation of concerns to a certain extent, in order to maintain a clear structure and better development and maintenance.

But many times, entity models are associated across modules, so how should the association relationship be defined?

Usually we will define entities with similar business in one module. **For entities in the same module, it is recommended to define navigation properties, that is, foreign key constraints are included in the database.**

For modules like **user modules**, entities in other modules need to be associated with users in many cases, so when defining other entities, you can only define the `UserId` property without defining the navigation property `User`.

> [!TIP]
> When possible, it is best to use foreign key constraints, which can ensure data integrity and consistency. When necessary, you can remove foreign key constraints.
>
> If you don't have foreign key constraints at the beginning, adding foreign key constraints later may be very troublesome.
