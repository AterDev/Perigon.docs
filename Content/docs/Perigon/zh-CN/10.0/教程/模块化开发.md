# 模块化开发

模块是相对独立的业务功能单元，通常根据业务领域进行划分。模块化开发可以提升代码的可维护性和复用性。

> 模块必须以`Mod`后缀命名。

## 管理模块

通过`studio`中的模块管理界面，可以非常方便的创建和删除模块，工具会自动跨程序集处理模块相关的依赖关系。

## 模块目录

模块自身在`src/Modules`中，是一个独立的项目。通常包括：

- Models： Dto模型
- Managers: 业务逻辑
- Services: 仅用于该模块的服务
- ModuleExtensions.cs：模块的扩展方法，用于注册模块相关的服务。

> [!TIP]
> 源代码生成器会在服务中自动注入模块的扩展方法，无需手动调用。

模块的实体在`src/Definition/Entity`项目中，通过目录名称(模块命名)进行区分。

## 模块的复用

模块可以跨解决方案进行复用，如客户管理模块，订单管理模块等。工具提供了模块的打包和安装命令，方便模块的分发和使用。

### 打包模块

要进行包，需要编辑`ModuleExtensions.cs`文件，该文件在创建模块时自动生成，如：

```csharp

public static class ModuleExtensions
{
    [DisplayName("Perigon::XXX")]
    [Description("注册 XXX 模块服务，包括密钥管理与 OAuth 核心逻辑")]
    public static IHostApplicationBuilder AddXXXMod(this IHostApplicationBuilder builder)
    {
        builder.AddModServices();
        return builder;
    }
    
    private static IHostApplicationBuilder AddModServices(this IHostApplicationBuilder builder)
    {
        // ...模块相关服务注册，如添加后台服务
        return builder;
    }

    // 自定义中间件注册，需要服务中手动调用
    public static WebApplication UseXXXModServices(this WebApplication app)
    {
        // ...模块相关中间件注册
        return app;
    }
}

```

- `[DisplayName]`：用来表示作者名称和包的显示名，使用`::`分隔，如"Perigon::文件管理模块"，如果没有发现`::`，则默认认为是作者名称，包显示名使用默认的模块名称。
- `[Description]`：用来描述包的作用和特点。
- `AddXXXMod`：模块的扩展方法，用来注册模块相关的服务，如果服务很多，可以拆分到私有方法`AddModServices`中。
- `UseXXXModServices`：模块的中间件注册方法，需要在服务中手动调用才能生效。

> [!NOTE]
> 通常`AddXXXMod`只包含该模块特定的服务注册


进行打包的模块，要满足：

- 除**实体**和**控制器**之外的代码都应该在模块项目中，如果引用了其他项目的代码，打包时会提示错误。


使用`perigon pack <模块名称> <服务名称>`命令进行打包，必须在项目根目录下执行，打包后将在根目录下生成`package-modules`目录，你可以看到打包生成的模块文件(zip格式)。

### 安装模块

请在项目根目录下执行：

```pwsh
perigon install <模块包路径> <服务名称>
```

安装完成后，重新加载解决方案，然后检查模块是否安装成功。
